import { ProjectFile } from '@/models/file.model';
import { FileUploadRequest } from '@/types/req/file.req';
import { FileUploadResponse, FileWithUserResponse } from '@/types/res/file.res';
import { fileRepositoryInstance } from '@/repositories/file.repo';
import { s3RepositoryInstance } from '@/repositories/s3.repo';
import { userRepositoryInstance } from '@/repositories/user.repo';
import logger from '@/libs/logger';

export class FileService {
    
    public async uploadFile(
        fileBuffer: Buffer, 
        uploadRequest: FileUploadRequest, 
        uploadedBy: string
    ): Promise<FileUploadResponse> {
        try {
            // Upload file to S3
            const fileUrl = await s3RepositoryInstance.uploadFile(
                fileBuffer,
                `project-files/${uploadRequest.projectId}`,
                uploadRequest.mimeType
            );

            // Create file record
            const projectFile: ProjectFile = {
                id: '', // Will be generated by repository
                projectId: uploadRequest.projectId,
                fileName: this.generateFileName(uploadRequest.fileName, uploadRequest.mimeType),
                originalName: uploadRequest.fileName,
                fileUrl: fileUrl,
                fileSize: uploadRequest.fileSize,
                mimeType: uploadRequest.mimeType,
                uploadedBy: uploadedBy,
                uploadedDate: new Date(),
                isDeleted: false
            };

            const createdFile = await fileRepositoryInstance.createFile(projectFile);

            // Generate signed URL for the uploaded file to return to client
            let signedUrl = createdFile.fileUrl;
            try {
                signedUrl = await s3RepositoryInstance.generateSignedUrl(createdFile.fileUrl);
            } catch (error) {
                logger.error(`Error generating signed URL for file ${createdFile.id}:`, error);
            }

            return {
                id: createdFile.id,
                fileName: createdFile.fileName,
                fileUrl: signedUrl,
                fileSize: createdFile.fileSize,
                mimeType: createdFile.mimeType,
                uploadedDate: createdFile.uploadedDate,
                uploadedBy: createdFile.uploadedBy
            };
        } catch (error) {
            logger.error('Error uploading file:', error);
            throw error;
        }
    }

    public async getProjectFiles(projectId: string): Promise<FileWithUserResponse[]> {
        try {
            const files = await fileRepositoryInstance.getFilesByProjectId(projectId);
            
            // Populate user information and generate signed URLs for each file
            const filesWithUserInfo = await Promise.all(
                files.map(async (file) => {
                    try {
                        const user = await userRepositoryInstance.findById(file.uploadedBy);
                        
                        // Generate signed URL for the file
                        let signedUrl = file.fileUrl;
                        try {
                            signedUrl = await s3RepositoryInstance.generateSignedUrl(file.fileUrl);
                        } catch (error) {
                            logger.error(`Error generating signed URL for file ${file.id}:`, error);
                        }
                        
                        return {
                            ...file,
                            fileUrl: signedUrl,
                            uploadedByUser: user ? {
                                id: user.id,
                                fullname: user.fullname,
                                email: user.email,
                                avatar: user.avatar
                            } : undefined
                        } as FileWithUserResponse;
                    } catch (error) {
                        logger.error(`Error getting user info for file ${file.id}:`, error);
                        return {
                            ...file,
                            uploadedByUser: undefined
                        } as FileWithUserResponse;
                    }
                })
            );
            
            return filesWithUserInfo;
        } catch (error) {
            logger.error('Error getting project files:', error);
            throw error;
        }
    }

    public async deleteFile(fileId: string, deletedBy: string): Promise<boolean> {
        try {
            const file = await fileRepositoryInstance.getFileById(fileId);
            if (!file) {
                throw new Error('File not found');
            }

            // Soft delete the file record
            const deletedFile = await fileRepositoryInstance.updateFile({
                ...file,
                isDeleted: true,
                deletedDate: new Date(),
                deletedBy: deletedBy
            });

            if (!deletedFile) {
                throw new Error('Failed to delete file record');
            }

            // Optionally delete from S3 as well
            // await s3RepositoryInstance.deleteFile(file.fileName);

            return true;
        } catch (error) {
            logger.error('Error deleting file:', error);
            throw error;
        }
    }

    public async getFileById(fileId: string): Promise<ProjectFile | null> {
        try {
            const file = await fileRepositoryInstance.getFileById(fileId);
            if (!file) {
                return null;
            }
            
            // Generate signed URL for the file
            try {
                const signedUrl = await s3RepositoryInstance.generateSignedUrl(file.fileUrl);
                return {
                    ...file,
                    fileUrl: signedUrl
                };
            } catch (error) {
                logger.error(`Error generating signed URL for file ${fileId}:`, error);
                return file; // Return file with original URL if signed URL generation fails
            }
        } catch (error) {
            logger.error('Error getting file by ID:', error);
            throw error;
        }
    }

    private generateFileName(originalName: string, mimeType: string): string {
        const timestamp = Date.now();
        const randomString = Math.random().toString(36).substring(2, 15);
        const extension = this.getFileExtension(mimeType);
        return `${timestamp}_${randomString}${extension}`;
    }

    private getFileExtension(mimeType: string): string {
        const extensionMap: { [key: string]: string } = {
            'image/jpeg': '.jpg',
            'image/jpg': '.jpg',
            'image/png': '.png',
            'image/gif': '.gif',
            'image/webp': '.webp',
            'image/svg+xml': '.svg',
            'application/pdf': '.pdf',
            'text/plain': '.txt',
            'application/json': '.json',
            'application/msword': '.doc',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document': '.docx',
            'application/vnd.ms-excel': '.xls',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': '.xlsx',
            'application/vnd.ms-powerpoint': '.ppt',
            'application/vnd.openxmlformats-officedocument.presentationml.presentation': '.pptx',
            'application/zip': '.zip',
            'application/x-rar-compressed': '.rar',
            'text/javascript': '.js',
            'text/html': '.html',
            'text/css': '.css',
            'text/x-python': '.py',
            'text/x-java-source': '.java',
        };
        
        return extensionMap[mimeType] || '.bin';
    }
}

export const fileServiceInstance = new FileService();
